<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Predicción | Monitoreo Energético PWA</title>

  <meta name="theme-color" content="#0b0f14" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  <style>
    :root{
      --bg:#0b0f14;
      --card:#121a23;
      --card2:#0f1620;
      --stroke:#223043;
      --text:#f2f6ff;
      --muted:#aab6c6;
      --accent:#00e5ff;
      --ok:#00c853;
      --warn:#ffab00;
      --bad:#ff1744;

      --radius:18px;
      --shadow: 0 10px 30px rgba(0,0,0,.35);

      --focus: rgba(0,229,255,.55);
      --focusBg: rgba(0,229,255,.12);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 800px at 20% -10%, rgba(0,229,255,.18), transparent 60%),
                  radial-gradient(900px 700px at 80% 0%, rgba(0,200,83,.12), transparent 55%),
                  var(--bg);
      color:var(--text);
    }

    a{ color:inherit; text-decoration:none; }
    button, input, select{ font:inherit; color:inherit; }

    .wrap{
      max-width:1100px;
      margin:0 auto;
      padding:18px 14px 30px;
    }

    /* Topbar */
    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:10px 12px;
      border:1px solid rgba(34,48,67,.7);
      border-radius: var(--radius);
      background: rgba(15,22,32,.75);
      backdrop-filter: blur(10px);
      position: relative;
      z-index: 50;
    }
    .brand{
      display:flex; align-items:center; gap:10px;
      min-width:0;
    }
    .logo{
      width:38px; height:38px;
      border-radius:12px;
      background: linear-gradient(135deg, rgba(0,229,255,.25), rgba(0,200,83,.18));
      border:1px solid rgba(34,48,67,.8);
      display:grid; place-items:center;
      box-shadow: var(--shadow);
      flex:0 0 auto;
    }
    .logo svg{ opacity:.95; }
    .brand .t{
      line-height:1.05;
      min-width:0;
    }
    .brand .t strong{
      display:block;
      font-size:14px;
      letter-spacing:.2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .brand .t span{
      display:block;
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      margin-top:2px;
    }

    .actions{ display:flex; gap:8px; flex:0 0 auto; align-items:center; }
    .btn{
      border:1px solid rgba(34,48,67,.9);
      background: rgba(18,26,35,.85);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      font-weight:650;
      font-size:12px;
      cursor:pointer;
      box-shadow: 0 10px 25px rgba(0,0,0,.25);
      display:inline-flex;
      align-items:center;
      gap:8px;
      user-select:none;
    }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      border-color: rgba(0,229,255,.55);
      background: rgba(0,229,255,.10);
    }
    .btn.icon{
      padding:10px 10px;
      width:40px;
      justify-content:center;
    }

    /* Submenu */
    .menu{
      position:absolute;
      top: calc(100% + 10px);
      right: 10px;
      width: 280px;
      border-radius: 16px;
      background: rgba(15,22,32,.92);
      border:1px solid rgba(34,48,67,.9);
      box-shadow: var(--shadow);
      overflow:hidden;
      display:none;
    }
    .menu.open{ display:block; }
    .menu .hd{
      padding:12px 12px 10px;
      border-bottom:1px solid rgba(34,48,67,.7);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .menu .hd strong{ font-size:13px; letter-spacing:.2px; }
    .menu .hd span{ font-size:12px; color:var(--muted); }
    .menu .items{ padding:10px; display:grid; gap:8px; }
    .menu a.item{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 10px;
      border-radius: 14px;
      border:1px solid rgba(34,48,67,.75);
      background: rgba(18,26,35,.55);
    }
    .menu a.item:hover{ border-color: rgba(0,229,255,.35); background: rgba(0,229,255,.07); }
    .menu .k{
      display:flex; align-items:center; gap:10px;
      min-width:0;
    }
    .menu .k .ic{
      width:28px; height:28px;
      border-radius:10px;
      display:grid; place-items:center;
      border:1px solid rgba(34,48,67,.75);
      background: rgba(15,22,32,.6);
      flex:0 0 auto;
    }
    .menu .k .tx{
      min-width:0;
    }
    .menu .k .tx b{
      display:block;
      font-size:12.5px;
      letter-spacing:.2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .menu .k .tx small{
      display:block;
      color:var(--muted);
      font-size:11.5px;
      margin-top:2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .menu .chev{ color: var(--muted); font-size:14px; }

    /* Layout */
    .grid{
      display:grid;
      gap:14px;
      margin-top:14px;
    }
    @media(min-width: 900px){
      .grid{
        grid-template-columns: 1.2fr .8fr;
        align-items:start;
      }
    }

    .card{
      border:1px solid rgba(34,48,67,.85);
      background: rgba(18,26,35,.75);
      border-radius: var(--radius);
      padding:16px;
      box-shadow: var(--shadow);
    }
    .card h2{
      margin:0 0 10px;
      font-size:16px;
      letter-spacing:.2px;
    }
    .card h3{
      margin:0 0 8px;
      font-size:13px;
      letter-spacing:.2px;
    }
    .card p{
      margin:0;
      color:var(--muted);
      line-height:1.55;
      font-size:13px;
    }
    .muted{ color:var(--muted); }

    /* Hero */
    .hero{
      padding:16px;
      border-radius: var(--radius);
      border:1px solid rgba(34,48,67,.85);
      background:
        linear-gradient(180deg, rgba(0,229,255,.12), rgba(0,0,0,0)),
        rgba(15,22,32,.75);
      box-shadow: var(--shadow);
    }
    .hero h1{
      margin:0 0 10px;
      font-size:22px;
      line-height:1.12;
      letter-spacing:.2px;
    }
    .hero .sub{
      margin:0;
      color:var(--muted);
      line-height:1.55;
      font-size:13.5px;
    }

    .chips{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top:12px;
    }
    .chip{
      font-size:12px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(34,48,67,.9);
      background: rgba(18,26,35,.65);
      color: var(--text);
      display:flex;
      align-items:center;
      gap:8px;
    }
    .dot{
      width:8px; height:8px; border-radius:99px;
      background: var(--warn);
      box-shadow: 0 0 0 4px rgba(255,171,0,.12);
      flex:0 0 auto;
    }
    .dot.ok{ background: var(--ok); box-shadow: 0 0 0 4px rgba(0,200,83,.12); }
    .dot.bad{ background: var(--bad); box-shadow: 0 0 0 4px rgba(255,23,68,.12); }

    /* Columns blocks */
    .cols{
      display:grid;
      gap:12px;
    }
    @media(min-width: 700px){
      .cols{ grid-template-columns: 1fr 1fr; }
    }
    .mini{
      background: rgba(15,22,32,.7);
      border:1px solid rgba(34,48,67,.75);
      border-radius: 16px;
      padding:14px;
    }
    .mini ul{
      margin:0;
      padding:0 0 0 16px;
      color:var(--muted);
      line-height:1.55;
      font-size:13px;
    }
    .mini li{ margin:4px 0; }

    /* Chart */
    .chartWrap{
      margin-top:10px;
      border:1px solid rgba(34,48,67,.75);
      background: rgba(15,22,32,.65);
      border-radius: 16px;
      overflow:hidden;
    }
    canvas{
      display:block;
      width:100%;
      height:220px;
    }
    .chartBar{
      padding:10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border-top:1px solid rgba(34,48,67,.7);
      color:var(--muted);
      font-size:12px;
      flex-wrap:wrap;
    }
    .seg{
      display:flex;
      gap:6px;
      align-items:center;
      flex-wrap:wrap;
    }
    .pillBtn{
      border:1px solid rgba(34,48,67,.75);
      background: rgba(18,26,35,.55);
      padding:8px 10px;
      border-radius: 999px;
      cursor:pointer;
      color: var(--text);
      font-weight:700;
      font-size:12px;
    }
    .pillBtn.active{
      border-color: rgba(0,229,255,.55);
      background: rgba(0,229,255,.10);
    }
    .legend{
      display:flex; gap:10px; flex-wrap:wrap;
      margin-top:10px;
      color: var(--muted);
      font-size:12px;
    }
    .pill{
      display:flex; align-items:center; gap:8px;
      border:1px solid rgba(34,48,67,.75);
      background: rgba(15,22,32,.65);
      padding:8px 10px;
      border-radius: 999px;
    }

    /* Forms */
    .form{
      margin-top:10px;
      display:grid;
      gap:10px;
    }
    .row2{
      display:grid;
      gap:10px;
    }
    @media(min-width: 650px){
      .row2{ grid-template-columns: 1fr 1fr; }
    }
    .field{
      background: rgba(15,22,32,.7);
      border:1px solid rgba(34,48,67,.8);
      border-radius: 16px;
      padding:10px;
    }
    .field label{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-size:12px;
      color: var(--muted);
      margin-bottom:8px;
    }
    .field label b{
      color: var(--text);
      font-size:12.5px;
      letter-spacing:.2px;
    }
    .field input, .field select{
      width:100%;
      padding:10px 10px;
      border-radius: 12px;
      border:1px solid rgba(34,48,67,.85);
      background: rgba(18,26,35,.6);
      outline: none;
    }
    .field input:focus, .field select:focus{
      border-color: var(--focus);
      box-shadow: 0 0 0 4px var(--focusBg);
    }
    .hint{
      margin-top:8px;
      color: var(--muted);
      font-size:11.5px;
      line-height:1.35;
    }
    .err{
      margin-top:8px;
      font-size:11.5px;
      color: rgba(255,23,68,.95);
      line-height:1.35;
      display:none;
    }
    .err.show{ display:block; }

    /* Results */
    .results{
      margin-top:10px;
      display:grid;
      gap:10px;
    }
    .resultBox{
      background: rgba(15,22,32,.7);
      border:1px solid rgba(34,48,67,.8);
      border-radius: 16px;
      padding:12px;
    }
    .resultBox .top{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .tag{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius: 999px;
      border:1px solid rgba(34,48,67,.75);
      background: rgba(18,26,35,.55);
      font-size:12px;
      font-weight:800;
    }
    .tag.ok{ border-color: rgba(0,200,83,.55); background: rgba(0,200,83,.10); }
    .tag.warn{ border-color: rgba(255,171,0,.55); background: rgba(255,171,0,.10); }
    .tag.bad{ border-color: rgba(255,23,68,.55); background: rgba(255,23,68,.10); }
    .vals{
      display:grid;
      gap:10px;
    }
    @media(min-width: 650px){
      .vals{ grid-template-columns: 1fr 1fr; }
    }
    .bigVal{
      border:1px solid rgba(34,48,67,.75);
      background: rgba(18,26,35,.55);
      border-radius: 16px;
      padding:12px;
    }
    .bigVal .k{ color: var(--muted); font-size:12px; }
    .bigVal .v{
      margin-top:6px;
      font-size:22px;
      font-weight:900;
      letter-spacing:-.3px;
      color: var(--accent);
    }
    .bigVal .u{ color: var(--muted); font-size:11.5px; margin-top:6px; line-height:1.35; }

    /* Table */
    table{
      width:100%;
      border-collapse: separate;
      border-spacing: 0;
      overflow:hidden;
      border-radius: 16px;
      border:1px solid rgba(34,48,67,.75);
      margin-top:10px;
      background: rgba(15,22,32,.65);
    }
    th, td{
      padding:10px 10px;
      text-align:left;
      font-size:12px;
      color: var(--muted);
      border-bottom:1px solid rgba(34,48,67,.55);
      vertical-align:top;
      white-space:nowrap;
    }
    th{ color: rgba(242,246,255,.9); font-weight:800; }
    tr:last-child td{ border-bottom:none; }
    td b{ color: rgba(242,246,255,.92); font-weight:800; }

    /* Footer note / code box */
    .footerNote{
      margin-top:14px;
      color: var(--muted);
      font-size:12px;
      line-height:1.55;
    }
    .code{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      color: rgba(242,246,255,.9);
      background: rgba(15,22,32,.7);
      border:1px solid rgba(34,48,67,.75);
      border-radius: 14px;
      padding:12px;
      overflow:auto;
      margin-top:10px;
      white-space: pre;
    }

    /* Sticky mobile bottom status */
    .bottom{
      position: sticky;
      bottom: 10px;
      margin-top: 14px;
      border-radius: 999px;
      padding: 10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      background: rgba(15,22,32,.75);
      border:1px solid rgba(34,48,67,.85);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      z-index: 10;
    }
    .bottom .left{
      display:flex; align-items:center; gap:10px;
      min-width:0;
    }
    .bottom .left .s{
      min-width:0;
      color: var(--muted);
      font-size:12px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .bottom .right{
      font-size:12px;
      font-weight:800;
      color: var(--text);
      white-space:nowrap;
    }

    /* Small helpers */
    .sp10{ height:10px; }
    .hr{
      height:1px;
      background: rgba(34,48,67,.6);
      margin:12px 0;
    }
    details summary { cursor: pointer; list-style: none; }
    details summary::-webkit-details-marker { display: none; }
    details summary h2 { display: inline; }

    /* ===== MOBILE OPTIMIZATION ===== */
    @media (max-width: 640px) {
      .hero p,
      .card p { display: none; }

      .hero h1 { font-size: 18px; line-height: 1.2; }
      .row2 { grid-template-columns: 1fr !important; }

      .field { padding: 10px; }

      #btnRun { font-size: 14px; padding: 14px; }

      .bigVal:nth-child(2) { display: none; }
    }

    /* ==============================
       FIX OVERFLOW MOBILE (no se sale de bordes)
       Pegar al FINAL del <style>
       ============================== */

    /* 1) Nunca permitir scroll horizontal */
    html, body { max-width: 100%; overflow-x: hidden; }
    .wrap { width: 100%; max-width: 1100px; overflow-x: hidden; }

    /* 2) Tarjetas y contenedores no deben expandir por contenido */
    .card, .hero, .topbar { max-width: 100%; }
    .card { overflow: hidden; } /* evita que elementos internos "rompan" la tarjeta */

    /* 3) Textos largos: permitir wrap en móvil */
    .brand, .brand .t { min-width: 0; }
    .brand .t strong,
    .brand .t span {
      white-space: normal !important;      /* quita nowrap */
      overflow: visible !important;
      text-overflow: clip !important;
      word-break: break-word;
    }

    /* 4) Topbar: permitir que se acomode en 2 filas sin reventar ancho */
    .topbar { flex-wrap: wrap; }
    .actions { flex-wrap: wrap; }
    .actions .btn { max-width: 100%; }

    /* 5) Menú: ancho adaptable a pantalla (280px en desktop, pero no desborda en móvil) */
    .menu {
      width: min(280px, calc(100vw - 28px));
      right: 14px;
    }

    /* 6) Chips: evitar que empujen el ancho */
    .chips { flex-wrap: wrap; max-width: 100%; }
    .chip { max-width: 100%; }

    /* 7) Tablas/código: si son anchos, que hagan scroll interno en lugar de romper layout */
    table { display: block; max-width: 100%; overflow-x: auto; }
    .code { max-width: 100%; overflow-x: auto; }

    /* 8) Ajustes extra para pantallas muy angostas */
    @media (max-width: 420px){
      .topbar { gap: 10px; }
      .actions { width: 100%; justify-content: flex-end; }
      .btn { padding: 10px 10px; }
    }
  </style>

  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#0b0f14">
</head>

<script>
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("/service-worker.js")
        .then(reg => {
          console.log("Service Worker registrado:", reg.scope);
        })
        .catch(err => {
          console.error("SW error:", err);
        });
    });
  }
</script>

<body>
  <div class="wrap">

    <div class="topbar" id="topbar">
      <div class="brand">
        <div class="logo" aria-hidden="true">
          <svg width="22" height="22" viewBox="0 0 24 24" fill="none">
            <path d="M13 2L4 14h7l-1 8 10-14h-7l0-6z" stroke="rgba(242,246,255,.9)" stroke-width="1.6" stroke-linejoin="round"/>
          </svg>
        </div>
        <div class="t">
          <strong>Predicción y Tendencias (PWA)</strong>
          <span>Consumo horario · Random Forest + XGBoost · Lecturas desde /api/readings</span>
        </div>
      </div>

      <div class="actions">
        <button class="btn" id="btnRefresh">Actualizar</button>
        <button class="btn primary" id="btnPredict">Predecir</button>
        <button class="btn icon" id="btnMenu" aria-label="Abrir menú" aria-expanded="false">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M5 7h14M5 12h14M5 17h14" stroke="rgba(242,246,255,.9)" stroke-width="1.8" stroke-linecap="round"/>
          </svg>
        </button>
      </div>

      <div class="menu" id="menu" role="menu" aria-label="Submenú">
        <div class="hd">
          <div>
            <strong>Navegación</strong><br/>
            <span id="menuSub">PWA · Online/Offline</span>
          </div>
          <button class="btn icon" id="btnCloseMenu" aria-label="Cerrar menú" style="width:36px;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M6 6l12 12M18 6L6 18" stroke="rgba(242,246,255,.9)" stroke-width="1.8" stroke-linecap="round"/>
            </svg>
          </button>
        </div>
        <div class="items">
          <a class="item" href="./index.html" role="menuitem">
            <div class="k">
              <span class="ic">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                  <path d="M4 10.5L12 4l8 6.5V20a1 1 0 0 1-1 1h-5v-6H10v6H5a1 1 0 0 1-1-1v-9.5z" stroke="rgba(242,246,255,.85)" stroke-width="1.6" stroke-linejoin="round"/>
                </svg>
              </span>
              <span class="tx">
                <b>Inicio</b>
                <small>Dashboard principal</small>
              </span>
            </div>
            <span class="chev">›</span>
          </a>

          <a class="item" href="./prediccion.html" role="menuitem" aria-current="page">
            <div class="k">
              <span class="ic">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                  <path d="M4 19V5M4 19h16M8 15l3-3 3 2 4-6" stroke="rgba(242,246,255,.85)" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </span>
              <span class="tx">
                <b>Predicción</b>
                <small>Modelos + tendencias</small>
              </span>
            </div>
            <span class="chev">›</span>
          </a>

          <a class="item" href="./datos.html" role="menuitem">
            <div class="k">
              <span class="ic">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                  <path d="M4 7h16M4 12h16M4 17h16" stroke="rgba(242,246,255,.85)" stroke-width="1.6" stroke-linecap="round"/>
                </svg>
              </span>
              <span class="tx">
                <b>Datos</b>
                <small>Historial y exportación</small>
              </span>
            </div>
            <span class="chev">›</span>
          </a>

          <a class="item" href="./config.html" role="menuitem">
            <div class="k">
              <span class="ic">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                  <path d="M12 15.2a3.2 3.2 0 1 0 0-6.4 3.2 3.2 0 0 0 0 6.4z" stroke="rgba(242,246,255,.85)" stroke-width="1.6"/>
                  <path d="M19.4 15a7.8 7.8 0 0 0 .1-1l2-1.6-2-3.5-2.5 1a7.8 7.8 0 0 0-1.7-1l-.4-2.7H9.1l-.4 2.7a7.8 7.8 0 0 0-1.7 1l-2.5-1-2 3.5 2 1.6a7.8 7.8 0 0 0 .1 1 7.8 7.8 0 0 0-.1 1l-2 1.6 2 3.5 2.5-1a7.8 7.8 0 0 0 1.7 1l.4 2.7h5.8l.4-2.7a7.8 7.8 0 0 0 1.7-1l2.5 1 2-3.5-2-1.6a7.8 7.8 0 0 0-.1-1z" stroke="rgba(242,246,255,.55)" stroke-width="1.2" stroke-linejoin="round"/>
                </svg>
              </span>
              <span class="tx">
                <b>Configuración</b>
                <small>API, dispositivo, offline</small>
              </span>
            </div>
            <span class="chev">›</span>
          </a>
        </div>
      </div>
    </div>

    <div class="hero" style="margin-top:14px;">
      <h1>Predicción del consumo: tendencias, picos y pronóstico (t+1 y t+24)</h1>
      <p class="sub">
        Esta pantalla toma tus lecturas desde el backend y construye un resumen temporal (por hora) para visualizar tendencias.
        Luego permite ejecutar predicciones con dos modelos (XGBoost y Random Forest) usando datos reales o valores ingresados.
      </p>

      <div class="chips">
        <div class="chip"><span class="dot" id="dotSystem"></span>Estado del sistema</div>
        <div class="chip"><span class="dot ok"></span>Lectura: /api/readings (con fallbacks)</div>
        <div class="chip"><span class="dot" id="dotModels"></span>Modelos: XGB + RF (server o fallback)</div>
        <div class="chip">Pronóstico: consumo horario (kWh)</div>
      </div>
    </div>

    <div class="grid">
      <div>
        <details class="card">
          <summary><h2>Información del modelo</h2></summary>
          <p>
            El enfoque está orientado a pronosticar el <b>consumo energético horario</b>. Se apoya en variables temporales
            (hora del día y día de la semana) y en variables eléctricas medidas (voltaje, corriente, potencia, energía activa).
            Para el modelado se comparan <b>Random Forest Regressor</b> y <b>XGBoost Regressor</b>, usando validación cruzada temporal.
          </p>

          <div class="cols" style="margin-top:12px;">
            <div class="mini">
              <h3>Qué se predice (target)</h3>
              <ul>
                <li><b>Consumo energético horario</b> (kWh) por laboratorio/dispositivo.</li>
                <li>Pronóstico <b>t+1</b> (siguiente hora) y <b>t+24</b> (siguiente día).</li>
                <li>Útil para anticipar <b>picos</b> y optimizar gestión energética.</li>
              </ul>
            </div>
            <div class="mini">
              <h3>Variables típicas (features)</h3>
              <ul>
                <li><b>Hora del día</b> (0–23) y <b>día de la semana</b> (0–6).</li>
                <li><b>Potencia</b> (W), <b>voltaje</b> (V), <b>corriente</b> (A).</li>
                <li><b>Energía activa</b> (Wh / kWh) y opcional: <b>tipo de carga</b>, <b>temperatura</b>.</li>
              </ul>
            </div>
          </div>

          <div class="hr"></div>

          <div class="cols">
            <div class="mini">
              <h3>Preparación de datos (resumen)</h3>
              <ul>
                <li>Se agrupan lecturas a nivel horario: <b>promedios</b> y <b>máximos</b>.</li>
                <li>Normalización Min-Max (0–1) y outliers con Z-score.</li>
                <li>Se generan curvas de carga para detectar patrones/picos.</li>
              </ul>
            </div>
            <div class="mini">
              <h3>Evaluación y criterio</h3>
              <ul>
                <li>Métricas: <b>RMSE</b>, <b>MAE</b> y <b>MAPE</b>.</li>
                <li>Referencia: <b>MAPE ≤ 10%</b> como umbral de aceptación.</li>
                <li>Se revisa estabilidad por día de la semana y sesgos.</li>
              </ul>
            </div>
          </div>

          <div class="code" id="modelBox">
Modelos comparados:
  - Random Forest Regressor (100–500 árboles, profundidad 3–10)
  - XGBoost Regressor (learning rate 0.05–0.10, árboles 100–500, profundidad 3–10)

Validación:
  - Cross-validation temporal (rolling window)

Salida deseada:
  - Predicción de consumo horario (kWh): t+1 y t+24
          </div>

          <div class="footerNote" id="noteModelSource">
            Estado: este módulo intenta usar endpoints de predicción del backend. Si no existen, usa un modo local para que el dashboard no quede vacío.
          </div>
        </details>

        <div class="card">
          <h2>Ingresar datos y predecir (validación estricta)</h2>
          <p>
            Puedes predecir usando el último dato real (autocompletar) o ingresando valores manualmente.
            El formulario impide valores fuera de rango para mantener predicciones consistentes en ambos modelos.
          </p>

          <div class="form">
            <div class="row2">
              <div class="field">
                <label>
                  <span><b>Modo de entrada</b></span>
                  <span class="muted" id="modeHint">Auto / Manual</span>
                </label>
                <select id="inMode">
                  <option value="auto">Autocompletar con última lectura</option>
                  <option value="manual">Ingresar manualmente</option>
                </select>
                <div class="hint">En modo Auto se usa tu último registro real desde la API.</div>
              </div>

              <div class="field">
                <label>
                  <span><b>Horizonte</b></span>
                  <span class="muted">t+1 / t+24</span>
                </label>
                <select id="horizon">
                  <option value="both">Predecir t+1 y t+24</option>
                  <option value="t1">Solo t+1 (1 hora)</option>
                  <option value="t24">Solo t+24 (24 horas)</option>
                </select>
                <div class="hint">Se devuelve consumo horario en kWh (o unidad que entregue tu backend).</div>
              </div>
            </div>

            <div class="row2">
              <div class="field">
                <label>
                  <span><b>Voltaje (V)</b></span>
                  <span class="muted">90–260</span>
                </label>
                <input id="v" type="number" step="0.1" min="90" max="260" placeholder="Ej: 120.0" />
                <div class="hint">Rango típico en redes 110–250V.</div>
                <div class="err" id="errV">Voltaje inválido (90–260 V).</div>
              </div>

              <div class="field">
                <label>
                  <span><b>Corriente (A)</b></span>
                  <span class="muted">0–100</span>
                </label>
                <input id="i" type="number" step="0.01" min="0" max="100" placeholder="Ej: 3.25" />
                <div class="hint">No se admiten negativos.</div>
                <div class="err" id="errI">Corriente inválida (0–100 A).</div>
              </div>
            </div>

            <div class="row2">
              <div class="field">
                <label>
                  <span><b>Potencia (W)</b></span>
                  <span class="muted">0–30000</span>
                </label>
                <input id="p" type="number" step="0.1" min="0" max="30000" placeholder="Ej: 420.5" />
                <div class="hint">Si no tienes potencia, se estima con V×I (asumiendo PF≈1).</div>
                <div class="err" id="errP">Potencia inválida (0–30000 W).</div>
              </div>

              <div class="field">
                <label>
                  <span><b>Energía activa (kWh)</b></span>
                  <span class="muted">≥ 0</span>
                </label>
                <input id="e" type="number" step="0.001" min="0" placeholder="Ej: 0.250" />
                <div class="hint">Si tu API usa Wh, el sistema intenta convertir automáticamente.</div>
                <div class="err" id="errE">Energía inválida (no puede ser negativa).</div>
              </div>
            </div>

            <div class="row2">
              <div class="field">
                <label>
                  <span><b>Hora del día</b></span>
                  <span class="muted">0–23</span>
                </label>
                <input id="hour" type="number" step="1" min="0" max="23" placeholder="Ej: 14" />
                <div class="hint">Se autocompleta desde la fecha del dato real.</div>
                <div class="err" id="errH">Hora inválida (0–23).</div>
              </div>

              <div class="field">
                <label>
                  <span><b>Día de la semana</b></span>
                  <span class="muted">0–6</span>
                </label>
                <select id="dow">
                  <option value="0">Domingo (0)</option>
                  <option value="1">Lunes (1)</option>
                  <option value="2">Martes (2)</option>
                  <option value="3">Miércoles (3)</option>
                  <option value="4">Jueves (4)</option>
                  <option value="5">Viernes (5)</option>
                  <option value="6">Sábado (6)</option>
                </select>
                <div class="hint">Se autocompleta con la fecha del dato.</div>
              </div>
            </div>

            <div class="row2">
              <div class="field">
                <label>
                  <span><b>Tipo de carga</b></span>
                  <span class="muted">categoría</span>
                </label>
                <select id="loadType">
                  <option value="computo">Cómputo (PCs / monitores)</option>
                  <option value="iluminacion">Iluminación</option>
                  <option value="equipos">Equipos auxiliares</option>
                  <option value="mixta">Mixta</option>
                </select>
                <div class="hint">Si tu backend no usa este campo, se ignora.</div>
              </div>

              <div class="field">
                <label>
                  <span><b>Temperatura (°C)</b> <span class="muted">(opcional)</span></span>
                  <span class="muted">0–60</span>
                </label>
                <input id="temp" type="number" step="0.1" min="0" max="60" placeholder="Ej: 26.0" />
                <div class="hint">Se envía solo si la ingresas. Se valida 0–60°C.</div>
                <div class="err" id="errT">Temperatura inválida (0–60 °C).</div>
              </div>
            </div>

            <div class="row2">
              <button class="btn primary" id="btnRun" style="justify-content:center;">Ejecutar predicción (XGB + RF)</button>
              <button class="btn" id="btnFill" style="justify-content:center;">Autocompletar desde último dato</button>
            </div>

            <div class="row2">
              <button type="button" class="btn" onclick="runLongTermPrediction('week')">
                Predicción 7 días
              </button>
              <button type="button" class="btn" onclick="runLongTermPrediction('month')">
                Predicción 30 días
              </button>
            </div>

            <div class="footerNote" id="formStatus">Estado: listo.</div>
          </div>

          <div class="results" id="results">
            <div class="resultBox">
              <div class="top">
                <div>
                  <div class="tag" id="tagXgb"><span class="dot" id="dotXgb"></span> XGBoost</div>
                  <div class="muted" style="margin-top:8px; font-size:12px;" id="srcXgb">Fuente: —</div>
                </div>
                <div class="muted" style="text-align:right; font-size:12px; line-height:1.35;" id="metaPred">
                  Última lectura: —<br/>Endpoint lectura: —<br/>Endpoint predicción: —
                </div>
              </div>
              <div class="vals">
                <div class="bigVal">
                  <div class="k">Predicción t+1</div>
                  <div class="v" id="xgbT1">—</div>
                  <div class="u" id="xgbT1U">Consumo horario (kWh)</div>
                </div>
                <div class="bigVal">
                  <div class="k">Predicción t+24</div>
                  <div class="v" id="xgbT24">—</div>
                  <div class="u" id="xgbT24U">Consumo horario (kWh)</div>
                </div>
              </div>
              <div class="footerNote" id="xgbNote">—</div>
            </div>

            <div class="resultBox">
              <div class="top">
                <div>
                  <div class="tag" id="tagRf"><span class="dot" id="dotRf"></span> Random Forest</div>
                  <div class="muted" style="margin-top:8px; font-size:12px;" id="srcRf">Fuente: —</div>
                </div>
                <div class="muted" style="text-align:right; font-size:12px; line-height:1.35;" id="metaPred2">
                  Modo: —<br/>Unidad: —<br/>Estado: —
                </div>
              </div>
              <div class="vals">
                <div class="bigVal">
                  <div class="k">Predicción t+1</div>
                  <div class="v" id="rfT1">—</div>
                  <div class="u" id="rfT1U">Consumo horario (kWh)</div>
                </div>
                <div class="bigVal">
                  <div class="k">Predicción t+24</div>
                  <div class="v" id="rfT24">—</div>
                  <div class="u" id="rfT24U">Consumo horario (kWh)</div>
                </div>
              </div>
              <div class="footerNote" id="rfNote">—</div>
            </div>

            <div class="resultBox" id="resultForecast">
              <div class="top">
                <div>
                  <div class="tag" id="tagForecast">
                    <span class="dot" id="dotForecast"></span>
                    Forecast (7–30 días)
                  </div>
                  <div class="muted" id="srcForecast">Fuente: histórico local</div>
                </div>
                <div class="muted" id="metaForecast">Horizonte: —</div>
              </div>

              <div class="vals">
                <div class="bigVal">
                  <div class="k">Consumo total proyectado</div>
                  <div class="v" id="ltTotal">—</div>
                  <div class="u">kWh acumulados</div>
                </div>
                <div class="bigVal">
                  <div class="k">Promedio diario</div>
                  <div class="v" id="ltAvg">—</div>
                  <div class="u">kWh / día</div>
                </div>
              </div>

              <div class="footerNote" id="ltNote">—</div>
            </div>

          </div>
        </div>
      </div>

      <div>
        <div class="card">
          <h2>Tendencias y visualización</h2>
          <p>
            Se construye una serie temporal con lecturas recientes. El gráfico muestra potencia estimada (W) y consumo horario estimado (kWh/h).
            Puedes cambiar el rango sin recargar la página.
          </p>

          <div class="chartWrap">
            <canvas id="chart" width="1000" height="220"></canvas>
            <div class="chartBar">
              <div class="seg">
                <button class="pillBtn active" data-range="1h" id="r1h">1h</button>
                <button class="pillBtn" data-range="6h" id="r6h">6h</button>
                <button class="pillBtn" data-range="24h" id="r24h">24h</button>
                <button class="pillBtn" data-range="7d" id="r7d">7d</button>
              </div>
              <div id="chartMeta">—</div>
            </div>
          </div>

          <div class="legend">
            <div class="pill"><span class="dot ok"></span>Potencia (W)</div>
            <div class="pill"><span class="dot"></span>Consumo (kWh/h)</div>
            <div class="pill"><span class="dot bad"></span>Picos (percentil 95)</div>
          </div>

          <table>
            <thead>
              <tr>
                <th>Hora</th>
                <th>V</th>
                <th>I</th>
                <th>P</th>
                <th>E</th>
              </tr>
            </thead>
            <tbody id="tbl">
              <tr><td colspan="5" class="muted">Esperando datos…</td></tr>
            </tbody>
          </table>

          <div class="footerNote" id="trendNote">Estado: esperando lectura desde API.</div>
        </div>

        <div class="card">
          <h2>API configurada</h2>
          <p>
            Esta pantalla intenta detectar automáticamente tu endpoint de lectura. Puedes fijarlo en <b>API_BASE</b>.
          </p>
          <div class="code" id="apiBox">API_BASE = (configurable en JS)</div>
          <div class="footerNote" id="apiResolved">Lectura detectada: —</div>
        </div>
      </div>
    </div>

    <div class="bottom">
      <div class="left">
        <span class="dot" id="dotBottom"></span>
        <div class="s" id="bottomText">Inicializando…</div>
      </div>
      <div class="right" id="bottomRight">PWA Ready</div>
    </div>
  </div>

  <script>
    /**
     * ==============================
     * CONFIGURACION
     * ==============================
     * Cambia SOLO si tu backend no es este:
     */
    const API_BASE = "https://iot-backend-ynkx.onrender.com";

    // ==============================
    // ✅ OPTIMIZACION: CACHE + TIMEOUTS + ENDPOINT LEARNING
    // ==============================
    const CACHE_KEYS = {
      read: "pwa_read_cache_v2",
      pred: "pwa_pred_cache_v2",
      long: "pwa_long_cache_v2"
    };

    function cacheLoad(key, fallback){
      try{
        const raw = localStorage.getItem(key);
        if(!raw) return fallback;
        const v = JSON.parse(raw);
        return (v === null || v === undefined) ? fallback : v;
      }catch(_){ return fallback; }
    }
    function cacheSave(key, value){
      try{ localStorage.setItem(key, JSON.stringify(value)); }catch(_){}
    }

    // Cache de lecturas (para pintar rápido)
    let READ_CACHE = cacheLoad(CACHE_KEYS.read, null);

    function getCachedReadingsSlice(N){
      if(!READ_CACHE || !Array.isArray(READ_CACHE.readings) || !READ_CACHE.readings.length) return null;
      const slice = READ_CACHE.readings.slice(-Math.min(N, READ_CACHE.readings.length)).map(r=>({
        tsMs: r.tsMs,
        ts: new Date(r.tsMs),
        v: (r.v ?? null),
        i: (r.i ?? null),
        p: (r.p ?? null),
        eKwh: (r.eKwh ?? null)
      }));
      return { ok:true, endpoint: READ_ENDPOINT, readings: slice, cached:true, ageMs: Date.now() - (READ_CACHE.ts||0) };
    }

    function storeReadingsCache(normalizedReadings){
      const compact = normalizedReadings.map(r => ({
        tsMs: r.tsMs,
        v: r.v, i: r.i, p: r.p, eKwh: r.eKwh
      }));
      const keep = compact.slice(-Math.min(900, compact.length));
      READ_CACHE = { ts: Date.now(), readings: keep };
      cacheSave(CACHE_KEYS.read, READ_CACHE);
    }

    // Cache de endpoints de predicción (aprende cuál funciona)
    let PRED_CACHE = cacheLoad(CACHE_KEYS.pred, {
      xgb: { path:null, okTs:0 },
      rf:  { path:null, okTs:0 },
      failUntil: { xgb:{}, rf:{} },       // { path: timestamp_until }
      noServerUntil: { xgb:0, rf:0 }      // si no hay endpoints, no reintentar por un rato
    });

    function markFail(modelKey, path, cooldownMs){
      const until = Date.now() + cooldownMs;
      if(!PRED_CACHE.failUntil[modelKey]) PRED_CACHE.failUntil[modelKey] = {};
      PRED_CACHE.failUntil[modelKey][path] = until;
      cacheSave(CACHE_KEYS.pred, PRED_CACHE);
    }

    function canTryPath(modelKey, path){
      const until = (PRED_CACHE.failUntil?.[modelKey]?.[path]) || 0;
      return Date.now() > until;
    }

    function setModelEndpointOk(modelKey, path){
      PRED_CACHE[modelKey] = { path, okTs: Date.now() };
      PRED_CACHE.noServerUntil[modelKey] = 0;
      cacheSave(CACHE_KEYS.pred, PRED_CACHE);
    }

    function setNoServerCooldown(modelKey, cooldownMs){
      PRED_CACHE.noServerUntil[modelKey] = Date.now() + cooldownMs;
      cacheSave(CACHE_KEYS.pred, PRED_CACHE);
    }

    // ==============================
    // PERFIL REAL DE TUS DATOS (IMPORTANTE)
    // ==============================
    const DATA_PROFILE = {
      daysAvailable: 5,        // solo tienes 5 dias (lun-vie)
      sampleEveryMin: 5,       // cada 5 minutos
      dayStartHour: 7,         // 07:00
      dayEndHour: 19,          // 19:00 (fin, no inclusivo)
      weekdaysOnly: true       // lun-vie
    };

    // Muestras esperadas por dia (07:00-19:00 cada 5 min) => 144
    function samplesPerMeasuredDay(){
      const minutes = (DATA_PROFILE.dayEndHour - DATA_PROFILE.dayStartHour) * 60;
      return Math.floor(minutes / DATA_PROFILE.sampleEveryMin);
    }

    // Total máximo esperable en tu BD (5 dias) => 720
    function maxSamplesAvailable(){
      return samplesPerMeasuredDay() * DATA_PROFILE.daysAvailable;
    }

    /**
     * Limita el LIMIT del backend a lo estrictamente necesario.
     * - Para ventana 7d: pedirias 1008, pero solo existen ~720 -> se capea.
     * - Para ventana 30d: pedirias 4320, pero solo existen ~720 -> se capea.
     * Se agrega un margen del 10% por si hay duplicados o desfases, sin pasarse del máximo.
     */
    function limitForWindowDays(daysWanted){
      const perDay = samplesPerMeasuredDay();
      const desired = perDay * daysWanted;
      const cap = maxSamplesAvailable();
      const withMargin = Math.ceil(Math.min(desired, cap) * 1.10);
      return Math.min(withMargin, cap);
    }

    // Filtra SOLO lo medido: lun-vie y 07:00-19:00
    function inMeasurementWindow(tsMs){
      const d = new Date(tsMs);
      const h = d.getHours();
      const dow = d.getDay(); // 0=dom ... 6=sab

      const hourOk = (h >= DATA_PROFILE.dayStartHour && h < DATA_PROFILE.dayEndHour);
      if(!hourOk) return false;

      if(DATA_PROFILE.weekdaysOnly){
        if(dow < 1 || dow > 5) return false;
      }
      return true;
    }

    /**
     * Endpoint fijo de lectura (sin autodetección lenta)
     */
    const READ_ENDPOINT = "/api/readings?limit={N}";

    /**
     * Endpoints candidatos (predicción)
     * Se prueban en orden por modelo.
     */
    const PRED_ENDPOINTS = {
      xgb: [
        "/api/predict/xgb",
        "/api/predict?model=xgb",
        "/api/prediction/xgb",
        "/api/models/xgb/predict"
      ],
      rf: [
        "/api/predict/rf",
        "/api/predict?model=rf",
        "/api/prediction/rf",
        "/api/models/rf/predict"
      ]
    };

    const POLL_MS = 150000;

    const TH_OK = 1;
    const TH_WARN = 3;

    const el = (id) => document.getElementById(id);

    function setDotState(dotEl, state){
      dotEl.classList.remove("ok","bad");
      if(state === "ok") dotEl.classList.add("ok");
      else if(state === "bad") dotEl.classList.add("bad");
    }

    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    function toIsoLocal(d){
      const z = (x)=> String(x).padStart(2,"0");
      return `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())} ${z(d.getHours())}:${z(d.getMinutes())}:${z(d.getSeconds())}`;
    }

    function fmtNum(x, digits=2){
      if(x === null || x === undefined || Number.isNaN(x)) return "—";
      return Number(x).toFixed(digits);
    }

    function fmtKwh(x){
      if(x === null || x === undefined || Number.isNaN(x)) return "—";
      if(x < 0.001) return (x*1000).toFixed(2) + " Wh";
      return x.toFixed(3) + " kWh";
    }

    function horizonLabel(h){
      if(h === "t1") return "t+1";
      if(h === "t24") return "t+24";
      return "t+1 y t+24";
    }

    async function fetchWithTimeout(url, opts={}, ms=9000){
      const ac = new AbortController();
      const id = setTimeout(()=>ac.abort(), ms);
      try{
        const res = await fetch(url, { ...opts, signal: ac.signal, cache: "no-store" });
        return res;
      } finally {
        clearTimeout(id);
      }
    }

    async function fetchJSON(url, opts={}, ms=9000){
      const res = await fetchWithTimeout(url, opts, ms);
      const txt = await res.text();
      let json = null;
      try{ json = txt ? JSON.parse(txt) : null; }catch(_){ json = null; }
      return { ok: res.ok, status: res.status, json, text: txt };
    }

    function pick(obj, keys){
      for(const k of keys){
        if(obj && obj[k] !== undefined && obj[k] !== null) return obj[k];
      }
      return null;
    }

    function inferV(r){
      const v = pick(r, ["v", "voltage", "voltaje", "vrms", "v_rms", "V", "voltage_rms"]);
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    }

    function inferI(r){
      const i = pick(r, ["i", "current", "corriente", "irms", "i_rms", "I", "current_rms"]);
      const n = Number(i);
      return Number.isFinite(n) ? n : null;
    }

    function inferP(r){
      const p = pick(r, ["p", "power", "potencia", "p_w", "power_w", "P", "active_power_w"]);
      const n = Number(p);
      return Number.isFinite(n) ? n : null;
    }

    function inferEraw(r){
      return pick(r, ["e", "energy", "energia", "energia_activa", "energy_active", "energy_wh", "energia_wh", "e_wh", "energy_kwh", "energia_kwh"]);
    }

    function inferE_kWh(r){
      const raw = inferEraw(r);
      const n = Number(raw);
      if(!Number.isFinite(n)) return null;

      const key = (() => {
        const entries = ["e", "energy", "energia", "energia_activa", "energy_active", "energy_wh", "energia_wh", "e_wh", "energy_kwh", "energia_kwh"];
        for(const k of entries){ if(r && r[k] !== undefined && r[k] !== null) return k; }
        return "";
      })();

      if(key.includes("wh") || key === "e_wh" || key === "energy_wh" || key === "energia_wh"){
        return n / 1000;
      }
      return n;
    }

    function inferTS(r){
      const ts = pick(r, ["ts", "timestamp", "time", "createdAt", "created_at", "date"]);
      if(!ts) return null;
      const d = new Date(ts);
      return Number.isFinite(d.getTime()) ? d.getTime() : null;
    }

    function normalizeReading(r){
      const tsMs = inferTS(r);
      const ts = tsMs ? new Date(tsMs) : new Date();
      const v = inferV(r);
      const i = inferI(r);
      let p = inferP(r);
      const eKwh = inferE_kWh(r);

      if(p === null && v !== null && i !== null){
        p = v * i;
      }

      return {
        raw: r,
        tsMs: ts.getTime(),
        ts,
        v,
        i,
        p,
        eKwh,
        deviceId: pick(r, ["deviceId","device_id","device","deviceID"]) ?? null
      };
    }

    function toHourKey(tsMs){
      const d = new Date(tsMs);
      const z = (x)=>String(x).padStart(2,"0");
      return `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}T${z(d.getHours())}`;
    }

    function groupHourly(readings){
      const m = new Map();

      for(const rr of readings){
        const d = new Date(rr.tsMs);
        const y = d.getFullYear();
        const mo = d.getMonth();      // 0-11
        const da = d.getDate();
        const h = d.getHours();

        const tsHour = new Date(y, mo, da, h, 0, 0, 0).getTime(); // ✅ cross-browser
        const hk = `${y}-${String(mo+1).padStart(2,"0")}-${String(da).padStart(2,"0")}T${String(h).padStart(2,"0")}`;

        if(!m.has(hk)){
          m.set(hk, { hourKey: hk, tsMs: tsHour, n:0, pSum:0, pMax:null, vSum:0, iSum:0 });
        }

        const g = m.get(hk);
        g.n += 1;

        if(Number.isFinite(rr.p)){
          g.pSum += rr.p;
          g.pMax = (g.pMax === null) ? rr.p : Math.max(g.pMax, rr.p);
        }
        if(Number.isFinite(rr.v)) g.vSum += rr.v;
        if(Number.isFinite(rr.i)) g.iSum += rr.i;
      }

      const out = Array.from(m.values()).sort((a,b)=>a.tsMs-b.tsMs);

      for(const g of out){
        g.pAvg = g.n ? (g.pSum / g.n) : null;
        g.vAvg = g.n ? (g.vSum / g.n) : null;
        g.iAvg = g.n ? (g.iSum / g.n) : null;
        g.kwh_h = (Number.isFinite(g.pAvg)) ? (g.pAvg / 1000) : null;
      }

      return out;
    }

    function groupDaily(hourlySeries){
      const m = new Map();

      for(const h of hourlySeries){
        const d = new Date(h.tsMs);
        const key = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,"0")}-${String(d.getDate()).padStart(2,"0")}`;

        if(!m.has(key)){
          m.set(key,{
            dayKey:key,
            tsMs:new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime(),
            kwhDay: 0,
            hoursCount: 0
          });
        }

        // h.kwh_h es energía estimada para ESA hora (kWh en 1 hora)
        if(Number.isFinite(h.kwh_h)){
          const g = m.get(key);
          g.kwhDay += h.kwh_h;      // ✅ energía diaria = suma de horas
          g.hoursCount += 1;
        }
      }

      return Array.from(m.values()).sort((a,b)=>a.tsMs-b.tsMs);
    }

    function longTermForecastFactory(dailySeries){
      if(!dailySeries || dailySeries.length < 3) return null;

      // y = energía diaria (kWh/día)
      const y = dailySeries.map(d => d.kwhDay).filter(Number.isFinite);
      const n = y.length;
      if(n < 3) return null;

      let sx=0, sy=0, sxy=0, sx2=0;
      y.forEach((v,i)=>{ sx+=i; sy+=v; sxy+=i*v; sx2+=i*i; });

      const denom = (n*sx2 - sx*sx);
      const slope = denom ? (n*sxy - sx*sy) / denom : 0;
      const mean = sy / n;

      // horas medidas promedio por día (para convertir a kW promedio)
      const hoursMeasuredAvg = (() => {
        const hs = dailySeries.map(d => d.hoursCount).filter(Number.isFinite);
        if(!hs.length) return 12; // fallback típico 07-19
        return hs.reduce((a,b)=>a+b,0) / hs.length;
      })();

      function forecast(days){
        let totalKwh = 0;
        for(let i=1;i<=days;i++){
          totalKwh += Math.max(0, mean + slope*i); // suma kWh/día
        }
        const kwhPerDay = totalKwh / days;

        // kW promedio equivalente durante horas medidas
        const kwAvg = kwhPerDay / Math.max(1, hoursMeasuredAvg);

        return {
          days,
          totalKwh,         // ✅ kWh total periodo
          kwhPerDay,        // ✅ kWh por día
          kwAvg,            // ✅ kW promedio (durante horas medidas)
          hoursMeasuredAvg
        };
      }

      return {
        week:  () => forecast(7),
        month: () => forecast(30)
      };
    }

    function percentile(arr, p){
      const a = arr.filter(x=>Number.isFinite(x)).slice().sort((x,y)=>x-y);
      if(!a.length) return null;
      const idx = (a.length - 1) * p;
      const lo = Math.floor(idx);
      const hi = Math.ceil(idx);
      if(lo === hi) return a[lo];
      const w = idx - lo;
      return a[lo]*(1-w) + a[hi]*w;
    }

    function drawChart(series, rangeLabel){
      const c = el("chart");
      const ctx = c.getContext("2d");

      const w = c.width, h = c.height;
      ctx.clearRect(0,0,w,h);


      ctx.globalAlpha = 1;
      ctx.lineWidth = 1;
      ctx.strokeStyle = "rgba(34,48,67,.9)";
      ctx.strokeRect(0.5,0.5,w-1,h-1);

      const padL = 40, padR = 16, padT = 12, padB = 26;
      const innerW = w - padL - padR;
      const innerH = h - padT - padB;

      const xs = series.map(s=>s.tsMs);
      const pVals = series.map(s=>s.pAvg);
      const kVals = series.map(s=>s.kwh_h);

      const xMin = Math.min(...xs);
      const xMax = Math.max(...xs);

      const pMax = Math.max(1, ...pVals.filter(Number.isFinite));
      const kMax = Math.max(0.001, ...kVals.filter(Number.isFinite));
      const p95 = percentile(pVals, 0.95);

      function xScale(x){
        if(xMax === xMin) return padL;
        return padL + ((x - xMin) / (xMax - xMin)) * innerW;
      }
      function yScaleP(p){
        const v = (Number.isFinite(p) ? p : 0);
        return padT + (1 - (v / pMax)) * innerH;
      }
      function yScaleK(k){
        const v = (Number.isFinite(k) ? k : 0);
        return padT + (1 - (v / kMax)) * innerH;
      }


      ctx.strokeStyle = "rgba(34,48,67,.45)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      for(let i=0;i<=4;i++){
        const yy = padT + (innerH/4)*i;
        ctx.moveTo(padL, yy);
        ctx.lineTo(padL + innerW, yy);
      }
      ctx.stroke();


      ctx.fillStyle = "rgba(242,246,255,.85)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      ctx.fillText("W", 8, padT+2);

      ctx.fillStyle = "rgba(170,182,198,.9)";
      ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
      for(let i=0;i<=4;i++){
        const yy = padT + (innerH/4)*i;
        const val = Math.round(pMax * (1 - i/4));
        ctx.fillText(String(val), 8, yy);
      }


      ctx.strokeStyle = "rgba(0,200,83,.9)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      let started = false;
      for(const s of series){
        const x = xScale(s.tsMs);
        const y = yScaleP(s.pAvg);
        if(!started){ ctx.moveTo(x,y); started = true; }
        else ctx.lineTo(x,y);
      }
      ctx.stroke();

    
      ctx.strokeStyle = "rgba(255,171,0,.9)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      started = false;
      for(const s of series){
        const x = xScale(s.tsMs);
        const y = yScaleK(s.kwh_h);
        if(!started){ ctx.moveTo(x,y); started = true; }
        else ctx.lineTo(x,y);
      }
      ctx.stroke();


      if(Number.isFinite(p95)){
        ctx.fillStyle = "rgba(255,23,68,.95)";
        for(const s of series){
          if(Number.isFinite(s.pAvg) && s.pAvg >= p95){
            const x = xScale(s.tsMs);
            const y = yScaleP(s.pAvg);
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI*2);
            ctx.fill();
          }
        }
      }


      ctx.fillStyle = "rgba(170,182,198,.95)";
      ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";

      const ticks = 4;
      for(let i=0;i<=ticks;i++){
        const t = xMin + (xMax-xMin)*(i/ticks);
        const d = new Date(t);
        const label = `${String(d.getHours()).padStart(2,"0")}:${String(d.getMinutes()).padStart(2,"0")}`;
        const x = xScale(t);
        ctx.fillText(label, x, padT + innerH + 6);
      }


      const last = series[series.length-1];
      el("chartMeta").textContent =
        `Rango: ${rangeLabel} · Pmax: ${Math.round(pMax)}W · Último: ${last ? toIsoLocal(new Date(last.tsMs)) : "—"}`;

      return { pMax, kMax, p95 };
    }

    function renderTable(readings){
      const tb = el("tbl");
      if(!readings.length){
        tb.innerHTML = `<tr><td colspan="5" class="muted">Sin datos</td></tr>`;
        return;
      }

      const last = readings.slice(-8).reverse();
      const rows = last.map(rr=>{
        const d = new Date(rr.tsMs);
        const hh = String(d.getHours()).padStart(2,"0");
        const mm = String(d.getMinutes()).padStart(2,"0");
        const time = `${hh}:${mm}`;

        const v = (rr.v !== null) ? fmtNum(rr.v,1)+" V" : "—";
        const i = (rr.i !== null) ? fmtNum(rr.i,2)+" A" : "—";
        const p = (rr.p !== null) ? fmtNum(rr.p,1)+" W" : "—";
        const e = (rr.eKwh !== null) ? fmtKwh(rr.eKwh) : "—";

        return `<tr>
          <td><b>${time}</b></td>
          <td>${v}</td>
          <td>${i}</td>
          <td>${p}</td>
          <td>${e}</td>
        </tr>`;
      }).join("");

      tb.innerHTML = rows;
    }

    function rangeMs(label){
      if(label === "1h") return 1*60*60*1000;
      if(label === "6h") return 6*60*60*1000;
      if(label === "24h") return 24*60*60*1000;
      if(label === "7d") return 7*24*60*60*1000;
      return 6*60*60*1000;
    }

    function setActiveRange(label){
      const ids = ["r1h","r6h","r24h","r7d"];
      for(const id of ids){
        const b = el(id);
        b.classList.toggle("active", b.dataset.range === label);
      }
    }

    // ✅ getReadings optimizado + cache (timeout menor)
    async function getReadings(N){
      const url = API_BASE + READ_ENDPOINT.replace("{N}", String(N));
      const r = await fetchJSON(url, {}, 6500);

      // ✅ Si el SW devolvió {offline:true} con HTTP 200, NO lo aceptes como datos reales
      if(r.ok && r.json && r.json.offline === true){
        return { ok:false, endpoint:READ_ENDPOINT, readings:[], error:"Offline/placeholder (service worker) - sin datos reales" };
      }

      if(!r.ok) return { ok:false, endpoint:READ_ENDPOINT, readings:[], error:`HTTP ${r.status}` };

      let arr = null;
      if(Array.isArray(r.json)) arr = r.json;
      else if(r.json && Array.isArray(r.json.readings)) arr = r.json.readings;
      else if(r.json && Array.isArray(r.json.data)) arr = r.json.data;
      else if(r.json && typeof r.json === "object") arr = [r.json];

      const normalized = (arr || [])
        .map(normalizeReading)
        .filter(x=>Number.isFinite(x.tsMs))
        .sort((a,b)=>a.tsMs-b.tsMs);

      storeReadingsCache(normalized);

      return { ok:true, endpoint:READ_ENDPOINT, readings:normalized, error:null };
    }

    async function getTrainingReadingsForModel(modelWindowDays){
      const N = limitForWindowDays(modelWindowDays);
      const res = await getReadings(N);
      if(!res.ok) return res;

      // Filtra SOLO lun-vie 07:00-19:00 (tu ventana real)
      // ⚠️ Si por zona horaria el filtro elimina casi todo, usa fallback sin filtrar
      const filtered = res.readings.filter(r => inMeasurementWindow(r.tsMs));
      if(filtered.length >= Math.min(80, Math.floor(res.readings.length * 0.25))){
        res.readings = filtered;
      } // si no, dejamos el histórico sin filtrar para no quedarnos en 0

      res.readings = res.readings.map(r => ({
        tsMs: r.tsMs,
        v: r.v,
        i: r.i,
        p: r.p,
        eKwh: r.eKwh
      }));

      return res;
    }

    function validateInputs(payload){
      const errs = [];

      const v = payload.v;
      const i = payload.i;
      const p = payload.p;
      const e = payload.e;
      const hour = payload.hour;
      const dow = payload.dow;
      const temp = payload.temp;

      const okV = Number.isFinite(v) && v >= 90 && v <= 260;
      const okI = Number.isFinite(i) && i >= 0 && i <= 100;
      const okP = Number.isFinite(p) && p >= 0 && p <= 30000;
      const okE = (e === null) || (Number.isFinite(e) && e >= 0);
      const okH = Number.isFinite(hour) && hour >= 0 && hour <= 23;
      const okD = Number.isFinite(dow) && dow >= 0 && dow <= 6;
      const okT = (temp === null) || (Number.isFinite(temp) && temp >= 0 && temp <= 60);

      el("errV").classList.toggle("show", !okV);
      el("errI").classList.toggle("show", !okI);
      el("errP").classList.toggle("show", !okP);
      el("errE").classList.toggle("show", !okE);
      el("errH").classList.toggle("show", !okH);
      el("errT").classList.toggle("show", !okT);

      if(!okV) errs.push("Voltaje inválido.");
      if(!okI) errs.push("Corriente inválida.");
      if(!okP) errs.push("Potencia inválida.");
      if(!okE) errs.push("Energía inválida.");
      if(!okH) errs.push("Hora inválida.");
      if(!okD) errs.push("Día inválido.");
      if(!okT) errs.push("Temperatura inválida.");

      return { ok: errs.length === 0, errs };
    }

    function makePayloadFromUI(){
      const v = Number(el("v").value);
      const i = Number(el("i").value);
      let p = Number(el("p").value);
      let e = el("e").value.trim() === "" ? null : Number(el("e").value);

      const hour = Number(el("hour").value);
      const dow = Number(el("dow").value);
      const loadType = el("loadType").value;

      const t = el("temp").value.trim() === "" ? null : Number(el("temp").value);

      if(!Number.isFinite(p) || el("p").value.trim()===""){
        if(Number.isFinite(v) && Number.isFinite(i)) p = v * i;
      }


      if(e !== null && Number.isFinite(e) && e > 200){
        e = e / 1000;
      }

      return {
        v: Number.isFinite(v) ? v : NaN,
        i: Number.isFinite(i) ? i : NaN,
        p: Number.isFinite(p) ? p : NaN,
        e: (e !== null && Number.isFinite(e)) ? e : null,
        hour: Number.isFinite(hour) ? hour : NaN,
        dow: Number.isFinite(dow) ? dow : NaN,
        loadType,
        temp: (t !== null && Number.isFinite(t)) ? t : null
      };
    }

    function stateFromKwh(kwh){
      if(!Number.isFinite(kwh)) return { label:"—", state:"warn" };
      if(kwh < TH_OK) return { label:"Óptimo", state:"ok" };
      if(kwh < TH_WARN) return { label:"Estable", state:"warn" };
      return { label:"Alto", state:"bad" };
    }

    function paintTag(tagEl, state){
      tagEl.classList.remove("ok","warn","bad");
      if(state === "ok") tagEl.classList.add("ok");
      else if(state === "bad") tagEl.classList.add("bad");
      else tagEl.classList.add("warn");
    }

    // ✅ DEAD_PRED: Almacena endpoints que dieron 404 para no retryar
    const DEAD_PRED = { xgb: new Set(), rf: new Set() };

    // ✅ tryPredictServer optimizado: aprende endpoint, cooldown, timeouts cortos, salta 404s
    async function tryPredictServer(modelKey, payload){
      const noUntil = PRED_CACHE.noServerUntil?.[modelKey] || 0;
      if(Date.now() < noUntil){
        return { ok:false, path:null, t1:null, t24:null, unit:"kWh", meta:null, raw:null, skipped:true };
      }

      const candidates = [];
      const cachedPath = PRED_CACHE?.[modelKey]?.path;

      if(cachedPath) candidates.push(cachedPath);
      for(const p of (PRED_ENDPOINTS[modelKey] || [])){
        if(!candidates.includes(p)) candidates.push(p);
      }

      function parsePred(j){
        const t1 = Number(pick(j, ["t1_kwh","t1","pred_t1","next_hour","yhat_t1"]));
        const t24 = Number(pick(j, ["t24_kwh","t24","pred_t24","next_day","yhat_t24"]));
        return {
          t1: Number.isFinite(t1) ? t1 : null,
          t24: Number.isFinite(t24) ? t24 : null,
          unit: pick(j, ["unit","units"]) ?? "kWh",
          meta: pick(j, ["meta","info","model"]) ?? null
        };
      }

      async function attempt(path, ms){
        const url = API_BASE + path;
        const r = await fetchJSON(url, {
          method: "POST",
          headers: { "content-type":"application/json" },
          body: JSON.stringify(payload)
        }, ms);

        // Si es 404, marca como muerto y no vuelvas a intentar
        if(r.status === 404){
          DEAD_PRED[modelKey].add(path);
          throw new Error("404-dead");
        }

        if(!r.ok || !r.json || typeof r.json !== "object") throw new Error("bad");
        const parsed = parsePred(r.json);
        if(parsed.t1 === null && parsed.t24 === null) throw new Error("nopreds");
        return { ok:true, path, ...parsed, raw:r.json };
      }

      if(cachedPath && canTryPath(modelKey, cachedPath) && !DEAD_PRED[modelKey].has(cachedPath)){
        try{
          const out = await attempt(cachedPath, 4500);
          setModelEndpointOk(modelKey, cachedPath);
          return out;
        }catch(_){
          if(_ !== "404-dead") markFail(modelKey, cachedPath, 10*60*1000);
        }
      }

      const list = candidates.filter(p => p !== cachedPath && canTryPath(modelKey, p) && !DEAD_PRED[modelKey].has(p));
      const FAIL_COOLDOWN = 10*60*1000;

      for(let idx=0; idx<Math.min(2, list.length); idx++){
        const path = list[idx];
        try{
          const out = await attempt(path, 3200);
          setModelEndpointOk(modelKey, path);
          return out;
        }catch(_){
          if(_ !== "404-dead") markFail(modelKey, path, FAIL_COOLDOWN);
        }
      }

      setNoServerCooldown(modelKey, 8*60*1000);
      return { ok:false, path:null, t1:null, t24:null, unit:"kWh", meta:null, raw:null };
    }

    function localPredictorFactory(hourlySeries){
      
      const byHour = new Map();
      for(const s of hourlySeries){
        const d = new Date(s.tsMs);
        const h = d.getHours();
        if(!byHour.has(h)) byHour.set(h, []);
        if(Number.isFinite(s.kwh_h)) byHour.get(h).push(s.kwh_h);
      }

      const hourMean = new Map();
      for(const [h, arr] of byHour.entries()){
        const m = arr.reduce((a,b)=>a+b,0) / Math.max(1, arr.length);
        hourMean.set(h, m);
      }

      const overall = (() => {
        const all = hourlySeries.map(s=>s.kwh_h).filter(Number.isFinite);
        if(!all.length) return 0.25;
        return all.reduce((a,b)=>a+b,0)/all.length;
      })();


      function predictRF(payload){
        const base = hourMean.get(payload.hour) ?? overall;


        const pTypical = (() => {
          const ps = hourlySeries
            .filter(s=>{
              const d = new Date(s.tsMs);
              return d.getHours() === payload.hour;
            })
            .map(s=>s.pAvg)
            .filter(Number.isFinite);

          if(!ps.length) return null;
          return percentile(ps, 0.5);
        })();

        let adj = 0;
        if(Number.isFinite(payload.p) && Number.isFinite(pTypical) && pTypical > 0){
          const ratio = clamp(payload.p / pTypical, 0.5, 2.0);
          adj = base * (ratio - 1) * 0.55;
        }
        const t1 = Math.max(0, base + adj);
        
        const t24 = Math.max(0, (hourMean.get(payload.hour) ?? overall) * 1.0);

        return { t1, t24, unit:"kWh", note:"Fallback local (perfil horario + ajuste robusto por potencia)." };
      }


      function predictXGB(payload){
        const base = hourMean.get(payload.hour) ?? overall;

        const h = payload.hour;
        const peakFactor = (h >= 9 && h <= 17) ? 1.12 : (h >= 7 && h < 9) ? 1.06 : 0.96;

        const vFactor = Number.isFinite(payload.v) ? clamp((payload.v - 110) / 40, -0.2, 0.2) : 0;
        const iFactor = Number.isFinite(payload.i) ? clamp((payload.i) / 20, 0, 1.2) : 0;

        const loadBoost = (payload.loadType === "computo") ? 0.08 :
                          (payload.loadType === "equipos") ? 0.06 :
                          (payload.loadType === "mixta") ? 0.04 : 0.02;

        const tempBoost = (payload.temp !== null && Number.isFinite(payload.temp)) ? clamp((payload.temp - 24) / 20, -0.08, 0.08) : 0;


        let pBoost = 0;
        
        if(Number.isFinite(payload.p)){
          const kw = payload.p / 1000;
          pBoost = clamp((kw - base) / Math.max(0.2, base), -0.3, 0.6);
        }

        const t1 = Math.max(0, base * peakFactor * (1 + 0.25*pBoost + 0.08*iFactor + 0.05*vFactor + loadBoost + tempBoost));
        const t24 = Math.max(0, (hourMean.get(payload.hour) ?? overall) * peakFactor);

        return { t1, t24, unit:"kWh", note:"Fallback local (no lineal suave con hora + potencia + tipo de carga)." };
      }

      return { predictRF, predictXGB };
    }

    function setPredictionUI(model, out, src){
      const isXgb = model === "xgb";

      const t1El = el(isXgb ? "xgbT1" : "rfT1");
      const t24El = el(isXgb ? "xgbT24" : "rfT24");

      const srcEl = el(isXgb ? "srcXgb" : "srcRf");
      const noteEl = el(isXgb ? "xgbNote" : "rfNote");

      const tagEl = el(isXgb ? "tagXgb" : "tagRf");
      const dotEl = el(isXgb ? "dotXgb" : "dotRf");

      const unit = out.unit || "kWh";

      t1El.textContent = (out.t1 === null) ? "—" : (Number(out.t1).toFixed(3) + " " + unit);
      t24El.textContent = (out.t24 === null) ? "—" : (Number(out.t24).toFixed(3) + " " + unit);

      srcEl.textContent = "Fuente: " + src;

      const best = (out.t1 !== null) ? out.t1 : out.t24;
      const st = stateFromKwh(best);

      setDotState(dotEl, st.state);
      paintTag(tagEl, st.state);

      noteEl.textContent = out.note || "—";
    }

    function setMetaPrediction(lastReading, readEndpoint, predEndpointX, predEndpointR){
      const last = lastReading ? toIsoLocal(new Date(lastReading.tsMs)) : "—";
      el("metaPred").innerHTML =
        `Última lectura: ${last}<br/>` +
        `Endpoint lectura: ${readEndpoint || "—"}<br/>` +
        `Endpoint predicción: ${predEndpointX || "—"}`;

      el("metaPred2").innerHTML =
        `Modo: ${predEndpointR ? "Backend" : "Fallback local"}<br/>` +
        `Unidad: kWh<br/>` +
        `Estado: ${lastReading ? "OK" : "Sin lectura"}`;
    }

    function fillFormFromReading(rr){
      const d = new Date(rr.tsMs);
      const hour = d.getHours();
      const dow = d.getDay();

      el("v").value = (rr.v !== null) ? rr.v.toFixed(1) : "";
      el("i").value = (rr.i !== null) ? rr.i.toFixed(2) : "";
      el("p").value = (rr.p !== null) ? rr.p.toFixed(1) : "";
      el("e").value = (rr.eKwh !== null) ? rr.eKwh.toFixed(3) : "";
      el("hour").value = String(hour);
      el("dow").value = String(dow);
    }

    let GLOBAL = {
      readings: [],
      hourly: [],
      daily: [],
      lastReading: null,
      readEndpoint: null,
      range: "6h",
      predictor: null,
      longForecast: null,
      refreshing: false,
      forecastBusy: false
    };

    // ✅ UI apply helper (para cache y para API)
    function applyReadingsToUI(res, label){
      GLOBAL.readings = res.readings;
      GLOBAL.readEndpoint = res.endpoint;
      GLOBAL.lastReading = res.readings[res.readings.length - 1] || null;

      el("apiResolved").textContent = `Lectura detectada: ${res.endpoint}${res.cached ? " (cache)" : ""}`;
      setDotState(el("dotSystem"), "ok");
      setDotState(el("dotBottom"), "ok");

      const lastTs = (GLOBAL.lastReading && GLOBAL.lastReading.tsMs) ? GLOBAL.lastReading.tsMs : Date.now();
      const ms = rangeMs(GLOBAL.range);
      const filtered = res.readings.filter(r => r.tsMs >= (lastTs - ms));


      const hourly = groupHourly(filtered);
      GLOBAL.hourly = hourly;
      GLOBAL.daily = groupDaily(hourly);
      GLOBAL.longForecast = longTermForecastFactory(GLOBAL.daily);
      
      GLOBAL.predictor = localPredictorFactory(hourly);


      if(hourly.length >= 2){
        drawChart(hourly, GLOBAL.range);
        el("trendNote").textContent = `${label} · Tendencias: ${hourly.length} puntos horarios · Rango: ${GLOBAL.range}`;
      } else {
        const pseudo = filtered.slice(-40).map(r=>({
          tsMs: r.tsMs,
          pAvg: r.p,
          kwh_h: (Number.isFinite(r.p) ? (r.p/1000) : null)
        }));
        if(pseudo.length >= 2){
          drawChart(pseudo, GLOBAL.range);
          el("trendNote").textContent = `${label} · Tendencias (muestras directas): ${pseudo.length} puntos · Rango: ${GLOBAL.range}`;
        } else {
          el("trendNote").textContent = `${label} · Datos insuficientes para tendencias.`;
        }
      }

      renderTable(filtered);

      if(el("inMode").value === "auto" && GLOBAL.lastReading){
        fillFormFromReading(GLOBAL.lastReading);
      }

      el("bottomText").textContent = `OK · ${label} · Lecturas: ${res.readings.length} · Endpoint: ${res.endpoint}`;
      el("menuSub").textContent = navigator.onLine ? "Online" : "Offline";
      setDotState(el("dotModels"), "ok");
    }

    // ✅ refreshTrends optimizado: cache instantáneo + fetch rápido + full async
    async function refreshTrends(){
      if(GLOBAL.refreshing) return;
      GLOBAL.refreshing = true;

      try{
        el("apiBox").textContent = `API_BASE = ${API_BASE}`;

        const LIMITS = {
          "1h": 40,
          "6h": 120,
          "24h": 288,
          "7d": limitForWindowDays(7)
        };
        const N = LIMITS[GLOBAL.range] || 120;

        const cached = getCachedReadingsSlice(N);
        if(cached && cached.readings.length){
          applyReadingsToUI(cached, "Cache local");
        } else {
          setDotState(el("dotSystem"), "bad");
          setDotState(el("dotBottom"), "bad");
          el("bottomText").textContent = "Cargando desde API…";
        }

        const fastN = Math.min(N, 180);
        const resFast = await getReadings(fastN);

        if(!resFast.ok){
          if(!cached){
            el("trendNote").textContent = `Sin datos desde API. Detalle: ${resFast.error || "—"}`;
            setDotState(el("dotSystem"), "bad");
            setDotState(el("dotBottom"), "bad");
            el("bottomText").textContent = `Sin conexión de lectura. ${resFast.error || ""}`;
            el("apiResolved").textContent = `Lectura detectada: —`;
          }
          return;
        }

        resFast.readings = resFast.readings.map(r => r.ts ? r : ({...r, ts:new Date(r.tsMs)}));
        applyReadingsToUI(resFast, "API (rápido)");

        if(N > fastN){
          el("trendNote").textContent = `API (rápido) · Cargando histórico completo (${N})…`;
          setTimeout(async ()=>{
            const resFull = await getReadings(N);
            if(resFull.ok){
              resFull.readings = resFull.readings.map(r => r.ts ? r : ({...r, ts:new Date(r.tsMs)}));
              applyReadingsToUI(resFull, "API (completo)");
            }
          }, 50);
        }
      } finally {
        GLOBAL.refreshing = false;
      }
    }

    // ✅ runPrediction optimizado: XGB/RF en paralelo (menos espera)
    async function runPrediction(){
      const mode = el("inMode").value;

      if(mode === "auto"){
        if(!GLOBAL.lastReading){
          el("formStatus").textContent = "Estado: no hay última lectura para autocompletar.";
          setDotState(el("dotBottom"), "bad");
          return;
        }
        fillFormFromReading(GLOBAL.lastReading);
      }

      const payload = makePayloadFromUI();
      const v = validateInputs(payload);

      if(!v.ok){
        el("formStatus").textContent = "Estado: corrige los campos inválidos para predecir.";
        setDotState(el("dotBottom"), "bad");
        return;
      }

      setDotState(el("dotBottom"), "ok");
      const horizon = el("horizon").value;
      el("formStatus").textContent = `Estado: ejecutando predicción (${horizonLabel(horizon)})…`;

      const [xgbServer, rfServer] = await Promise.all([
        tryPredictServer("xgb", payload),
        tryPredictServer("rf", payload)
      ]);

      const hasServerAny = (xgbServer.ok || rfServer.ok);

      if(xgbServer.ok){
        const out = {
          t1: (horizon === "t24") ? null : xgbServer.t1,
          t24:(horizon === "t1") ? null : xgbServer.t24,
          unit: xgbServer.unit || "kWh",
          note: "Respuesta desde backend (modelo XGBoost)."
        };
        setPredictionUI("xgb", out, `Backend: ${xgbServer.path}`);
        el("srcXgb").textContent = `Fuente: backend (${xgbServer.path})`;
      } else {
        const outLocal = GLOBAL.predictor ? GLOBAL.predictor.predictXGB(payload) : { t1:null, t24:null, unit:"kWh", note:"Fallback local sin histórico suficiente." };
        const out = {
          t1: (horizon === "t24") ? null : outLocal.t1,
          t24:(horizon === "t1") ? null : outLocal.t24,
          unit: outLocal.unit,
          note: outLocal.note
        };
        setPredictionUI("xgb", out, "Fallback local");
      }

      if(rfServer.ok){
        const out = {
          t1: (horizon === "t24") ? null : rfServer.t1,
          t24:(horizon === "t1") ? null : rfServer.t24,
          unit: rfServer.unit || "kWh",
          note: "Respuesta desde backend (modelo Random Forest)."
        };
        setPredictionUI("rf", out, `Backend: ${rfServer.path}`);
        el("srcRf").textContent = `Fuente: backend (${rfServer.path})`;
      } else {
        const outLocal = GLOBAL.predictor ? GLOBAL.predictor.predictRF(payload) : { t1:null, t24:null, unit:"kWh", note:"Fallback local sin histórico suficiente." };
        const out = {
          t1: (horizon === "t24") ? null : outLocal.t1,
          t24:(horizon === "t1") ? null : outLocal.t24,
          unit: outLocal.unit,
          note: outLocal.note
        };
        setPredictionUI("rf", out, "Fallback local");
      }

      setMetaPrediction(
        GLOBAL.lastReading,
        GLOBAL.readEndpoint,
        xgbServer.ok ? xgbServer.path : null,
        rfServer.ok ? rfServer.path : null
      );

      if(hasServerAny){
        el("noteModelSource").textContent = "Estado: predicción desde backend disponible (al menos un modelo).";
        setDotState(el("dotModels"), "ok");
      } else {
        el("noteModelSource").textContent = "Estado: no se detectaron endpoints de predicción, usando fallback local.";
        setDotState(el("dotModels"), "bad");
      }

      el("formStatus").textContent = `Estado: predicción completada (${horizonLabel(horizon)}).`;
    }

    // ✅ Forecast 7/30 optimizado: usa card (no alert) + cache + carga real del backend
    let LONG_CACHE = cacheLoad(CACHE_KEYS.long, null);

    async function ensureLongTermHistory(){
      if(GLOBAL._longReady && GLOBAL._longForecastFull) return true;

      if(LONG_CACHE && Array.isArray(LONG_CACHE.daily) && LONG_CACHE.daily.length >= 3){
        const daily = LONG_CACHE.daily.map(d => ({...d}));
        const lf = longTermForecastFactory(daily);
        if(lf){
          GLOBAL._longReady = true;
          GLOBAL._longForecastFull = lf;
          GLOBAL._longDaily = daily;
          return true;
        }
      }

      el("metaForecast").textContent = "Horizonte: — (cargando histórico…)";
      el("ltNote").textContent = "Cargando datos reales del backend para forecast…";
      setDotState(el("dotForecast"), "warn");
      paintTag(el("tagForecast"), "warn");

      const res = await getTrainingReadingsForModel(30);
      if(!res.ok || !res.readings || res.readings.length < 50){
        setDotState(el("dotForecast"), "bad");
        paintTag(el("tagForecast"), "bad");
        el("ltNote").textContent = "No hay datos suficientes para predicción a mediano plazo.";
        return false;
      }

      const hourly = groupHourly(res.readings);
      const daily = groupDaily(hourly);
      const lf = longTermForecastFactory(daily);

      if(!lf){
        setDotState(el("dotForecast"), "bad");
        paintTag(el("tagForecast"), "bad");
        el("ltNote").textContent = "Datos insuficientes (mínimo 3 días) para forecast.";
        return false;
      }

      LONG_CACHE = {
        ts: Date.now(),
        daily: daily.map(d => ({ dayKey:d.dayKey, tsMs:d.tsMs, kwh:d.kwh, n:d.n }))
      };
      cacheSave(CACHE_KEYS.long, LONG_CACHE);

      GLOBAL._longReady = true;
      GLOBAL._longForecastFull = lf;
      GLOBAL._longDaily = daily;

      return true;
    }

    function withTimeout(promise, ms){
      return Promise.race([
        promise,
        new Promise((_, rej)=>setTimeout(()=>rej(new Error("timeout")), ms))
      ]);
    }

    async function ensureLongForecast(days){
      // Si ya existe y es usable
      if(GLOBAL.longForecast && GLOBAL.daily && GLOBAL.daily.length >= 3) return true;

      // 1) Intenta refrescar tendencias (con timeout)
      try{
        await withTimeout(refreshTrends(), 16000);
      } catch(_){}

      if(GLOBAL.longForecast && GLOBAL.daily && GLOBAL.daily.length >= 3) return true;

      // 2) Fetch mínimo dedicado (cargamos lo necesario para 7/30)
      const res = await getTrainingReadingsForModel(days);
      if(!res.ok || !res.readings || res.readings.length < 50) return false;

      const hourly = groupHourly(res.readings);
      const daily = groupDaily(hourly);

      GLOBAL.daily = daily;
      GLOBAL.longForecast = longTermForecastFactory(daily);

      return !!GLOBAL.longForecast;
    }

    function runLongTermPrediction(type){
      const days = (type === "month") ? 30 : 7;

      // Construir forecast si falta
      if(!GLOBAL.longForecast && GLOBAL.daily && GLOBAL.daily.length >= 3){
        GLOBAL.longForecast = longTermForecastFactory(GLOBAL.daily);
      }

      if(!GLOBAL.longForecast){
        el("metaForecast").textContent = `Horizonte: ${days} días · Sin histórico suficiente`;
        el("ltTotal").textContent = "—";
        el("ltAvg").textContent = "—";
        el("ltNote").textContent = "No hay datos suficientes para estimar 7–30 días.";
        setDotState(el("dotForecast"), "bad");
        paintTag(el("tagForecast"), "bad");
        return;
      }

      const res = (days === 30) ? GLOBAL.longForecast.month() : GLOBAL.longForecast.week();

      // ✅ kWh total del periodo (semana/mes)
      el("ltTotal").textContent = `${res.totalKwh.toFixed(2)} kWh`;

      // ✅ kWh por día
      el("ltAvg").textContent = `${res.kwhPerDay.toFixed(2)} kWh/día`;

      // ✅ kW promedio equivalente (lo que tú llamas “kW por día”)
      const kwAvgTxt = `${res.kwAvg.toFixed(3)} kW promedio`;

      el("metaForecast").textContent = `Horizonte: ${days} días · Horas/día usadas: ${res.hoursMeasuredAvg.toFixed(1)}h`;
      el("srcForecast").textContent = "Fuente: histórico (API + baseline)";

      el("ltNote").textContent =
        (days === 30)
          ? `Mes: Energía total ${res.totalKwh.toFixed(2)} kWh · Potencia promedio del mes: ${kwAvgTxt}.`
          : `Semana: Energía total ${res.totalKwh.toFixed(2)} kWh · Potencia promedio diaria: ${kwAvgTxt}.`;

      setDotState(el("dotForecast"), "ok");
      paintTag(el("tagForecast"), "ok");
    }

    // Menu handlers
    function openMenu(){
      el("menu").classList.add("open");
      el("btnMenu").setAttribute("aria-expanded","true");
    }
    function closeMenu(){
      el("menu").classList.remove("open");
      el("btnMenu").setAttribute("aria-expanded","false");
    }

    // PWA: manifest + service worker (inline)
    function setupPWA(){
      try{
        // ✅ NO crear manifest dinámico por Blob (genera "Manifest start_url invalid")
        // Usar el manifest.json real de la raíz del proyecto.
        // El <link rel="manifest" href="/manifest.json"> ya está en HTML.
        // El /service-worker.js real (archivo físico) se registra automáticamente.
        // No crear manifest ni SW dinámicos. Usa los archivos estáticos del proyecto.
      }catch(_){}
    }

    // Wire events
    el("btnRefresh").addEventListener("click", refreshTrends);
    el("btnPredict").addEventListener("click", runPrediction);
    el("btnRun").addEventListener("click", runPrediction);
    el("btnFill").addEventListener("click", ()=>{
      if(GLOBAL.lastReading) fillFormFromReading(GLOBAL.lastReading);
    });

    el("btnMenu").addEventListener("click", ()=>{
      const open = el("menu").classList.contains("open");
      if(open) closeMenu(); else openMenu();
    });
    el("btnCloseMenu").addEventListener("click", closeMenu);

    document.addEventListener("click", (e)=>{
      const menu = el("menu");
      const btn = el("btnMenu");
      if(!menu.classList.contains("open")) return;
      if(menu.contains(e.target) || btn.contains(e.target)) return;
      closeMenu();
    });

    document.addEventListener("keydown", (e)=>{
      if(e.key === "Escape") closeMenu();
    });

    // Range buttons
    for(const id of ["r1h","r6h","r24h","r7d"]){
      el(id).addEventListener("click", ()=>{
        GLOBAL.range = el(id).dataset.range;
        setActiveRange(GLOBAL.range);
        refreshTrends();
      });
    }

    // Mode change
    el("inMode").addEventListener("change", ()=>{
      const m = el("inMode").value;
      el("modeHint").textContent = (m === "auto") ? "Auto" : "Manual";
      if(m === "auto" && GLOBAL.lastReading) fillFormFromReading(GLOBAL.lastReading);
    });

    // Live validation
    const inputs = ["v","i","p","e","hour","temp","dow","loadType"];
    for(const id of inputs){
      const node = el(id);
      node.addEventListener("input", ()=>{
        const payload = makePayloadFromUI();
        const v = validateInputs(payload);
        el("formStatus").textContent = v.ok ? "Estado: listo." : "Estado: hay campos inválidos.";
      });
      node.addEventListener("change", ()=>{
        const payload = makePayloadFromUI();
        const v = validateInputs(payload);
        el("formStatus").textContent = v.ok ? "Estado: listo." : "Estado: hay campos inválidos.";
      });
    }

    // Online/offline updates
    window.addEventListener("online", ()=>{ el("menuSub").textContent = "Online"; el("bottomRight").textContent = "Online"; });
    window.addEventListener("offline", ()=>{ el("menuSub").textContent = "Offline"; el("bottomRight").textContent = "Offline"; });

    // Init
    setupPWA();
    setDotState(el("dotSystem"), "bad");
    setDotState(el("dotBottom"), "bad");
    setDotState(el("dotModels"), "bad");
    el("apiBox").textContent = `API_BASE = ${API_BASE}`;
    el("bottomText").textContent = "Inicializando lectura y tendencias…";
    el("bottomRight").textContent = navigator.onLine ? "Online" : "Offline";

    (async ()=>{
      await refreshTrends();
      if(GLOBAL.lastReading){
        fillFormFromReading(GLOBAL.lastReading);
        validateInputs(makePayloadFromUI());
        await runPrediction();
      }
    })();

    setInterval(refreshTrends, POLL_MS);
  </script>
</body>
</html>
